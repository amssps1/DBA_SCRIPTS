USE [msdb]
GO

/****** Object:  Job [BCK_ALL_DBS]    Script Date: 27/06/2025 09:09:34 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]    Script Date: 27/06/2025 09:09:34 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'BCK_ALL_DBS', 
		@enabled=0, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'No description available.', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [01-Shrink Log All Simple DBs]    Script Date: 27/06/2025 09:09:34 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'01-Shrink Log All Simple DBs', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=3, 
		@on_success_step_id=0, 
		@on_fail_action=4, 
		@on_fail_step_id=2, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'
DECLARE @DatabaseName SYSNAME;
DECLARE @LogicalLogName SYSNAME;
DECLARE @SQL NVARCHAR(MAX);

DECLARE db_cursor CURSOR LOCAL FAST_FORWARD FOR
SELECT name
FROM sys.databases
WHERE database_id > 4                          -- Exclui master, tempdb, model, msdb
  AND recovery_model_desc = ''SIMPLE''           -- Apenas bases em SIMPLE
  AND state_desc = ''ONLINE''                    -- Apenas bases ONLINE
  AND is_read_only = 0;                        -- Exclui bases read-only

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @DatabaseName;

WHILE @@FETCH_STATUS = 0
BEGIN
    -- Obtem o nome lógico do ficheiro de log da base
    SELECT TOP 1 @LogicalLogName = name
    FROM sys.master_files
    WHERE database_id = DB_ID(@DatabaseName)
      AND type_desc = ''LOG'';

    -- Constrói e executa o comando DBCC SHRINKFILE
    SET @SQL = ''
    USE ['' + @DatabaseName + ''];
    DBCC SHRINKFILE (N'''''' + @LogicalLogName + '''''', 1);
    PRINT ''''Shrink realizado em ['' + @DatabaseName + ''] - Log: '' + @LogicalLogName + '''''';
    '';
    
    EXEC sp_executesql @SQL;

    FETCH NEXT FROM db_cursor INTO @DatabaseName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;
', 
		@database_name=N'master', 
		@flags=4
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [02- Backup Full All DBs]    Script Date: 27/06/2025 09:09:34 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'02- Backup Full All DBs', 
		@step_id=2, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'/*=====================================================================
   SCRIPT DE BACKUP FULL + CÓPIA PARA RETENÇÃO
   Autor  : PERSEU
   Data   : 2025-06-24
======================================================================*/

-----------------------------------------------------------------------
-- 0. GARANTIR QUE EXISTE A TABELA DE LOG DE ERROS
-----------------------------------------------------------------------
IF DB_ID(N''dba_db'') IS NULL
    RAISERROR (''A base de dados dba_db não existe.'', 16, 1);

IF OBJECT_ID(N''dba_db.dbo.Backup_ErrosLog'') IS NULL
BEGIN
    USE dba_db;
    CREATE TABLE dbo.Backup_ErrosLog
    (
        ID            INT IDENTITY(1,1) PRIMARY KEY,
        DatabaseName  SYSNAME        NOT NULL,
        BackupType    VARCHAR(10)    NOT NULL,
        ErroMensagem  NVARCHAR(MAX)  NOT NULL,
        DataErro      DATETIME       NOT NULL DEFAULT GETDATE(),
        BackupPath    NVARCHAR(500)  NULL,
        ScriptStep    VARCHAR(50)    NULL
    );
END
GO

-----------------------------------------------------------------------
-- 1. PARÂMETROS GERAIS E VARIÁVEIS
-----------------------------------------------------------------------
DECLARE @BackupHoje        VARCHAR(500) = ''M:\Backup_Dia'';
DECLARE @BackupRetencao    VARCHAR(500) = ''M:\Backup_Retencao'';

DECLARE @HojeData          CHAR(8)      = CONVERT(CHAR(8), GETDATE(), 112);          -- YYYYMMDD
DECLARE @OntemData         CHAR(8)      = CONVERT(CHAR(8), DATEADD(DAY, -1, GETDATE()), 112);
DECLARE @HoraData          CHAR(6)      = REPLACE(CONVERT(CHAR(8), GETDATE(), 108), '':'', ''''); -- HHMMSS
DECLARE @DateTimeSufixo    NVARCHAR(20) = @HojeData + ''_'' + @HoraData;

-- Activar xp_cmdshell (se já activo não faz mal)
EXEC sp_configure ''show advanced options'', 1;
RECONFIGURE;
EXEC sp_configure ''xp_cmdshell'', 1;
RECONFIGURE;

-----------------------------------------------------------------------
-- 2. MOVER BACKUPS (ONTEM) PARA PASTA DE RETENÇÃO
-----------------------------------------------------------------------
IF OBJECT_ID(''tempdb..#BakFiles'') IS NOT NULL DROP TABLE #BakFiles;

CREATE TABLE #BakFiles
(
    FullPath  NVARCHAR(500),
    FileName  NVARCHAR(260)
);

-- listar todos os .bak e .trn do dia anterior
INSERT INTO #BakFiles (FullPath)
EXEC xp_cmdshell ''for /R "M:\Backup_Dia" %i in (*.bak *.trn) do @echo %i'';

-- limpar nulos e extrair nome do ficheiro
DELETE FROM #BakFiles WHERE FullPath IS NULL;
UPDATE #BakFiles
SET FileName = REVERSE(LEFT(REVERSE(FullPath), CHARINDEX(''\'', REVERSE(FullPath)) - 1));

DECLARE 
    @FullPath    NVARCHAR(500),
    @FileName    NVARCHAR(260),
    @BaseName    NVARCHAR(128),
    @ArchiveDir  NVARCHAR(500),
    @CMD         NVARCHAR(1000);

DECLARE FileCursor CURSOR FAST_FORWARD FOR
    SELECT FullPath FROM #BakFiles
	-- copia todos os que lá estiverem
    --WHERE FullPath NOT LIKE ''%'' + @HojeData + ''%'';   -- ignora ficheiros de hoje

OPEN FileCursor;
FETCH NEXT FROM FileCursor INTO @FullPath;

WHILE @@FETCH_STATUS = 0
BEGIN
    /* determinar nome do ficheiro */
    SET @FileName = REVERSE(LEFT(REVERSE(@FullPath), CHARINDEX(''\'', REVERSE(@FullPath)) - 1));

    /* descobrir nome da base */
    IF CHARINDEX(''_full_'', @FileName) > 0
        SET @BaseName = LEFT(@FileName, CHARINDEX(''_full_'', @FileName) - 1);
    ELSE IF CHARINDEX(''_log_'', @FileName) > 0
        SET @BaseName = LEFT(@FileName, CHARINDEX(''_log_'', @FileName) - 1);
    ELSE
        SET @BaseName = NULL;

    IF @BaseName IS NOT NULL
    BEGIN
        SET @ArchiveDir = @BackupRetencao + ''\'' + @OntemData + ''\'' + @BaseName;

        -- cria pasta destino, se necessário
        SET @CMD = ''IF NOT EXIST "'' + @ArchiveDir + ''" mkdir "'' + @ArchiveDir + ''"'';
        EXEC xp_cmdshell @CMD;

        -- move ficheiro
        SET @CMD = ''move /Y "'' + @FullPath + ''" "'' + @ArchiveDir + ''\"'';
        EXEC xp_cmdshell @CMD;
    END

    FETCH NEXT FROM FileCursor INTO @FullPath;
END

CLOSE FileCursor;
DEALLOCATE FileCursor;
DROP TABLE #BakFiles;


-----------------------------------------------------------------------
-- 3. BACKUP FULL DAS BASES (2 ficheiros)
-----------------------------------------------------------------------
DECLARE 
    @DBName          SYSNAME,
    @BackupFileBase  VARCHAR(2000),
    @SQL             NVARCHAR(MAX);

DECLARE db_cursor CURSOR FAST_FORWARD FOR
SELECT name
FROM sys.databases
--WHERE name NOT IN (''tempdb'', ''ComunicacaoParceiros'', ''ControlosPermanentes'',''db_cofidis_dah'',''db_cofidis_dah_interface'',''AdministracaoSistemas'',''db_cofidis_dah_interface_aux'',''db_cofidis_dah_transactionlog'',''ExtratoCofidis'',''dba_db'',''FactCofidis'')
WHERE name NOT IN (''tempdb'')

  --AND state_desc = ''ONLINE''
ORDER BY name;

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @DBName;

WHILE @@FETCH_STATUS = 0
BEGIN
    BEGIN TRY
        /* cria pasta da base se não existir */
        SET @CMD = ''IF NOT EXIST "'' + @BackupHoje + ''\'' + @DBName + ''" mkdir "'' + @BackupHoje + ''\'' + @DBName + ''"'';
        EXEC xp_cmdshell @CMD;

        /* caminho base do backup */
        SET @BackupFileBase = @BackupHoje + ''\'' + @DBName + ''\'' + @DBName + ''_full_'' + @DateTimeSufixo;

        /* instrução de backup (2 ficheiros) */
        SET @SQL = N''
            BACKUP DATABASE ['' + @DBName + N'']
            TO 
                DISK = N'''''' + @BackupFileBase + N''_1.bak'''',
                DISK = N'''''' + @BackupFileBase + N''_2.bak''''
            WITH INIT, COMPRESSION, STATS = 5, NAME = N''''Full Backup of '' + @DBName + N'''''''';

        PRINT ''Backup FULL (2 ficheiros): '' + @DBName;
        EXEC (@SQL);
    END TRY
    BEGIN CATCH
        DECLARE @ErroMsg NVARCHAR(MAX) = ERROR_MESSAGE();

        INSERT INTO dba_db.dbo.Backup_ErrosLog
        (
            DatabaseName,
            BackupType,
            ErroMensagem,
            BackupPath,
            ScriptStep
        )
        VALUES
        (
            @DBName,
            ''FULL'',
            @ErroMsg,
            @BackupFileBase + ''_1.bak'',
            ''Backup FULL''
        );

        PRINT ''Erro no backup da base '' + @DBName + '': '' + @ErroMsg;
    END CATCH;

    FETCH NEXT FROM db_cursor INTO @DBName;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;


', 
		@database_name=N'msdb', 
		@flags=4
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'01-Schedule', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20250618, 
		@active_end_date=99991231, 
		@active_start_time=193000, 
		@active_end_time=235959, 
		@schedule_uid=N'a2efa059-15fc-4967-a0ee-fdafaf142255'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:
GO


